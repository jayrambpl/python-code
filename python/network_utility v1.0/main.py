import subprocess
import platform
import psutil
import tkinter as tk
from tkinter import ttk, filedialog
from tabulate import tabulate
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from datetime import datetime
import threading
from tkinter import messagebox
import time
from datetime import timedelta
from icecream import ic
ic.enable()

class ServerUtility:
    def __init__(self):
        self.servers = []
        self.ping_results = []
        self.service_list = []
        self.service_results = []
        self.progress = 0
        self.total_servers = 0

    def ping_servers(self, success_label, failure_label, progress_var, status_label):
        start_time = time.time()
        self.log_text.delete(1.0, tk.END)  # Clear log
        self.result_pass_text.delete(1.9, tk.END)
        self.result_fail_text.delete(1.0,tk.END)
        
        self.ping_results = []  # Clear existing ping results
        self.progress = 0
        self.total_servers = len(self.servers)

        success_ips = []  # To store successful ping IPs
        failure_ips = []  # To store failed ping IPs
        
        for i, server in enumerate(self.servers, start=1):
            try:
                # Perform ping
                ping_cmd = ["ping", "-n", "1"] if platform.system().lower() == "windows" else ["ping", "-c", "1"]
                result = subprocess.run(ping_cmd + [server], capture_output=True, text=True, timeout=5)
                
                # Check ping result
                success = "Destination host unreachable" not in result.stdout
                self.ping_results.append({"Server": server, "Ping Success": success, "Ping Output": result.stdout.strip()})
                
                # Log the result
                self.log_text.insert(tk.END, f"Ping result for {server}: {result.stdout.strip()}\n")

                # Update success/failure IPs
                if success:
                    success_ips.append(server)
                    self.result_pass_text.insert(tk.END, f"{server}\n")
                else:
                    failure_ips.append(server)
                    self.result_fail_text.insert(tk.END, f"{server}\n")

            except Exception as e:
                self.ping_results.append({"Server": server, "Ping Success": False, "Ping Output": str(e)})
                
                # Log the error
                self.log_text.insert(tk.END, f"Error pinging {server}: {str(e)}\n")

            # Update progress
            self.progress = (i / self.total_servers) * 100
            progress_var.set(int(self.progress))
            status_label["text"] = f"Status: {i} out of {self.total_servers} completed."
            end_time = time.time()  
            elapsed_time = end_time - start_time
            formatted_time = str(timedelta(seconds=elapsed_time)).split(".")[0]
            self.time_taken_label["text"] = f"Time Taken: {formatted_time}"
        # Display success/failure IPs in labels
        # success_label["text"] = f"Ping Success IPs: {', '.join(success_ips)}"
        # failure_label["text"] = f"Ping Failure IPs: {', '.join(failure_ips)}"
        end_time = time.time()  
        elapsed_time = end_time - start_time
        formatted_time = str(timedelta(seconds=elapsed_time)).split(".")[0]
        self.time_taken_label["text"] = f"Time Taken: {formatted_time}"
        
        # Generate reports after ping is completed
        self.generate_reports()

    def generate_pdf_report(self, results, filename, report_type):
        pdf_doc = SimpleDocTemplate(filename, pagesize=letter)
        elements = []

        # Add title and date to the header
        title = f"{report_type} Report - {datetime.now().strftime('%d-%b-%Y %I:%M %p')}"
        elements.append(Paragraph(title, getSampleStyleSheet()["Title"]))

        headers = list(results[0].keys()) if results else []
        data = [list(result.values()) for result in results]

        table = Table([headers] + data)
        style = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ])
        table.setStyle(style)

        elements.append(table)

        # Add footer
        footer = f"Report generated by Rajesh Kharche"
        elements.append(Paragraph(footer, getSampleStyleSheet()["BodyText"]))

        pdf_doc.build(elements)

    def service_status(self, servers):
        self.service_results = []  # Clear existing service results
        for server_ip in servers:
            for service_name in self.service_list:
                try:
                    # Check if the service is running (case-insensitive comparison)
                    # service_status = any(service.lower() == s.name().lower() for s in psutil.win_service_iter())
                    # Get all running services on the specified server
                    
                    connections = psutil.net_connections(kind='inet')
                    is_running = any(conn.laddr.ip == server_ip and conn.laddr.port == int(service_name) for conn in connections)

                    # service = psutil.win_service_get(service_name, machine=server_ip)
                    # service_status = "Running" in service.status()
                    
                    # ip = your_ip
                    # server_user = your_serviceuser
                    # server_pass = your_pass
                    # command = f"net use \\\\{ip} {server_pass} /USER:{server_user}"
                    # os.system(command)
                    # command = f"SC \\\\{ip} query SQLSERVERAGENT"
                    # process = subprocess.Popen(command, stdout=subprocess.PIPE)
                    # output, err = process.communicate()
                    
                    # output = str(str(str(str(output)[2:-1].replace(' ', '')).replace('\\t', '')).replace('\\r', '')).split('\\n')
                    # if output[3] != 'STATE:4RUNNING':
                    #     print("service is running...")

                    # Check if the specified service is in the list of running services
                    # services = psutil.net_connections(kind='inet', status='LISTEN', laddr=(server_ip, 0))
                    # is_running = any(service.laddr[1] == int(service_name) for service in services)

                    # if service_status:
                    #     print(f"The service '{service_name}' is running on {server_ip}.")
                    # else:
                    #     print(f"The service '{service_name}' is not running on {server_ip}.")

                    # ---------------
                    # query_cmd = f'sc.exe query "{service_name}" | findstr RUNNING'
                    # result_query = subprocess.run(query_cmd, capture_output=True, text=True, timeout=5)
                    # service_status = "RUNNING" in result_query.stdout.upper()

                    # self.service_results.append({"Server": result['Server'], f"{service} Status": "Running" if service_status else "Not Running"})
                    
                    # Log the result
                    self.log_text.insert(tk.END, f"{service_name} status for {server_ip}: {'Running' if is_running else 'Not Running'}\n")
                except Exception as e:
                    # self.service_results.append({"Server": result['Server'], f"{service} Status": "Not Running", "Error": str(e)})
                    ic(e)
                    # Log the error
                    self.log_text.insert(tk.END, f"Error getting {service_name} status for {server_ip}: {str(e)}\n")

    def generate_reports(self):
        # Generate PDF for success report
        success_results = [result for result in self.ping_results if result['Ping Success']]
        success_report_filename = f"Pass_Report_{datetime.now().strftime('%d-%b-%Y_%I-%M-%S%p')}.pdf"  # Include seconds in the timestamp
        self.generate_pdf_report(success_results, success_report_filename, "Pass")

        # Generate PDF for failure report
        failure_results = [result for result in self.ping_results if not result['Ping Success']]
        failure_report_filename = f"Fail_Report_{datetime.now().strftime('%d-%b-%Y_%I-%M-%S%p')}.pdf"  # Include seconds in the timestamp
        self.generate_pdf_report(failure_results, failure_report_filename, "Fail")

class ServerUtilityGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Server Utility v1.0")
        self.root.geometry("350x450")

        self.server_utility = ServerUtility()

        # Frame for server list and buttons
        frame = ttk.Frame(root, padding="10")
        frame.grid(column=0, row=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Label for server list
        ttk.Label(frame, text="Server List:").grid(column=0, row=0, sticky=tk.W)
         # Browse button
        ttk.Button(frame, text="Browse", command=self.browse_server_list).grid(column=1, row=1, sticky=tk.W)
        # Server list Text widget with scroll bar
        self.server_list_text = tk.Text(frame, height=4, width=15)
        self.server_list_text.grid(column=0, row=1, sticky=(tk.W, tk.E))
        # self.server_list_text.insert(tk.END, "192.168.29.133\n192.168.29.11\n192.168.29.0\n192.168.29.10\n192.168.29.11\n192.168.29.132")

       

        # PING command button
        ttk.Button(frame, text="PING", command=self.ping_command).grid(column=0, row=2, sticky=tk.W)

        # Service command button
        ttk.Button(frame, text="Service Command", command=self.service_command).grid(column=1, row=2, sticky=tk.W)

        
        # Progress bar
        self.progress_var = tk.IntVar()
        ttk.Progressbar(frame, variable=self.progress_var, length=100, mode='determinate').grid(column=0, row=3, columnspan=2, sticky=(tk.W, tk.E))
        # Status Label
        self.status_label = ttk.Label(frame, text="Status: ")
        self.status_label.grid(column=0, row=4, columnspan=2, sticky=tk.W)
        #  Time Taken
        self.server_utility.time_taken_label = ttk.Label(frame, text="Time Taken: ")
        self.server_utility.time_taken_label.grid(column=0, row=5, sticky=tk.W)
       
        # Success and failure labels
        self.success_label = ttk.Label(frame, text="Pass IPs :")
        self.success_label.grid(column=0, row=6, sticky=tk.W)
        tk.Text(frame, height=4, width=15)

        self.failure_label = ttk.Label(frame, text="Failed IPs :")
        self.failure_label.grid(column=1, row=6, sticky=tk.W)

        
        
        #  Result
        self.server_utility.result_pass_text = tk.Text(frame, height=4, width=15)
        self.server_utility.result_pass_text.grid(column=0, row=7, sticky=(tk.W, tk.E))
        
        self.server_utility.result_fail_text = tk.Text(frame, height=4, width=15)
        self.server_utility.result_fail_text.grid(column=1, row=7, sticky=(tk.W, tk.E))

        # Log Text widget
        ttk.Label(frame, text="Log:").grid(column=0, row=8, sticky=tk.W)
        self.server_utility.log_text = tk.Text(frame, height=10, width=40)
        self.server_utility.log_text.grid(column=0, row=9, columnspan=2,sticky=(tk.W, tk.E))

    def browse_server_list(self):
        try:
            file_path = filedialog.askopenfilename(title="Select Server List File", filetypes=[("Text files", "*.txt")])
            if file_path:
                with open(file_path, "r") as file:
                    server_list = file.read()
                    self.server_list_text.delete(1.0, tk.END)
                    self.server_list_text.insert(tk.END, server_list)
        except Exception as e:
            self.messagebox.showerror("Error", f"Error opening file: {e}")

            self.status_label["text"] = f"Status: Error opening file."
            return
        
    def ping_command(self):
        server_list = self.server_list_text.get(1.0, tk.END).strip().split("\n")
        self.server_utility.servers = server_list

        # Create a new thread for ping to avoid freezing the GUI
        ping_thread = threading.Thread(target=self.server_utility.ping_servers, args=(self.success_label, self.failure_label, self.progress_var, self.status_label))
        ping_thread.start()

    def service_command(self):
        # Service command should only run for Ping success servers
        self.server_utility.service_list = ["Bonjour Service","wuauserv", "wscsvc", "TrustedInstaller","gitlab-runner" ]

        success_servers = [result['Server'] for result in self.server_utility.ping_results if result['Ping Success']]
        self.server_utility.service_status(success_servers)
        self.status_label["text"] = f"Status: Service command executed."

if __name__ == "__main__":
    root = tk.Tk()
    app = ServerUtilityGUI(root)
    root.mainloop()
